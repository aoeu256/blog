Note that OOP in the Smalltalk sense included the meaning that everything is “first-class” or “late-bound” (for example Lisp had “first-class functions”, “first-class code”, however it had second-class special forms (you can overwrite let, cond, quote, set, defun, lambda with macros but you can’t pass them as an argument to other functions [this was fixed by the Kernel language*]). However, you could go into the eval function and write your own eval so Lisp had “first-class semantics”: its semantics could be turned into a concrete “object” that could be passed around and acted upon. Loop strategies [iterators?] could also be objectified and they were given names like map, filter, reduce(inject). Note that Haskell’s Monads (esp FreeMonads) and the related concept of Algebraic Effects are in the spirit of this form of “OOP” since they let you treat the side-effects, semicolons, context of a computation pipeline, and function application operators as “objects” to be named, combined, and passed at will.

Next every single thing should have a graphical representation so that you could interactively code, and not only should methods be objects but the process of sending messages itself should be an object that can be changed, the same with the process of creating classes (metaclasses). If you look at this definition of OOP it means something more than everything should be written in terms of static single-dispatch ADTs with methods known at compile time without “lambdas” or “blocks” so that code balloons to huge sizes.

Alan Kay didn’t really care about inheritance look it up, and I don’t know if Alan Kay cared about #5. One thing thats *DEFINATELY* missing the ability to live view a function as you edit it/having the ability to inspect code as it is running.

Another big key is #1, and Alan Kay said everything should be “late-bound” which means everything in the language should be sort-of like Lisp and changeable, and no its not just about int and strings its about if statement being an object, blocks being objects(first-class functions i.e: treating functions as objects), message dispatch mechanism being an object (Lisp apply) and changeable, messages being objects (so they can get dispatched to other objects or logged), loop strategies being objects (iterators like map, filter, reduce(inject)).

New functional languages have stuff like programmable semicolons and algebraic effect handlers/side-effects and this is probably what Alan Kay by everything should be an object, and in Lisp you could make your own version of eval so I think Alan Kay wouldn’t have objected to having “first-class semantics”, i.e: each object is its own computer / interpreter. Alan Kay also seemed to like talking about “reactive” programming and publish/subscribe and automatic propagation of “constraints” which where we should be going.

