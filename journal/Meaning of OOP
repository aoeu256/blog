Note that OOP in the Smalltalk sense included the meaning that everything is “first-class” or “late-bound” (for example Lisp had “first-class functions”, “first-class code”, however it had second-class special forms (you can overwrite let, cond, quote, set, defun, lambda with macros but you can’t pass them as an argument to other functions [this was fixed by the Kernel language*]). However, you could go into the eval function and write your own eval so Lisp had “first-class semantics”: its semantics could be turned into a concrete “object” that could be passed around and acted upon. Loop strategies [iterators?] could also be objectified and they were given names like map, filter, reduce(inject). Note that Haskell’s Monads (esp FreeMonads) and the related concept of Algebraic Effects are in the spirit of this form of “OOP” since they let you treat the side-effects, semicolons, context of a computation pipeline, and function application operators as “objects” to be named, combined, and passed at will.

Next every single thing should have a graphical representation so that you could interactively code, and not only should methods be objects but the process of sending messages itself should be an object that can be changed, the same with the process of creating classes (metaclasses). If you look at this definition of OOP it means something more than everything should be written in terms of static single-dispatch ADTs with methods known at compile time without “lambdas” or “blocks” so that code balloons to huge sizes.
